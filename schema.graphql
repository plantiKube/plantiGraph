type Query {
    exampleLambda(exampleStringInput: String!): String! @lambda
#    addTwo(addTwoInput: twoNums!): Int! @lambda
    addTwo(one: Int!, two: Int!): Int! @lambda
}

input twoNums {
    one: Int!
    two: Int!
}

type Mutation {
    ingestQR(qr: String!): String! @lambda
}


type CropIntentionsList {
    cropIntentions: [CropIntention!]!
}

type CropIntention {
    crop: Crop!
    harvestPerWeek: Int!
}

type GrowPlate {
    rawNetCupReading: Int

}

# name something like `SignalCluster` rather than `SignalTable` ..
# .. to illustrate it's a graph now and not an array?
# They are in some sense isometric semantic vectors so perhaps this is irrelevant.
type SignalTable {
    signals: [Signal!]!
}

type Signal {
    signalDate: DateTime!
    signalType: SignalType!
    plantName: String!
    plantId: String # this should be elsewhere in the structure.
    targetMessage: String
    algoString: String
    daysToGerminate: Int
    growTime: Int
    maxHarvTime: Int
    moduleType: String!
}

enum SignalType {
    GERMINATE
    TRANSFER
    HARVEST
}

type DeploymentMap {
    modules: [Module]
}

type Module {
    id: ID!
    shelves: [Shelf]
    totalNumberOfSites: Int! @lambda
}

type Shelf {
    sites: [Site]
}

type Site {
    id: ID!
    ocupant: Plant
}

type Plant {
    id: ID!
    xid: String
    cropName: String! @search
    repeater: Boolean! @search
    nutrientType: String! @search
    germinatedDate: DateTime
    transferredDate: DateTime
    harvestedDate: DateTime
}

# Abstract meta parameters for a crop.
type Crop {
    id: ID!
    xid: String
    name: String!
    required_module_type: String!
    repeater: Boolean!
    days_harvestable: Int!
    days_from_transfer_to_first_harvest: Int!
    harvests_per_week: Int!
}

type Seed {
    qr: String!
}

type Drawer {
    gridLocation: Location!
    cropAssignment: Crop
    stock: Int
}

type Location {
    x: Int!
    y: Int!
}

type GerminationTray {
    sitesAvailable: Int!
}
